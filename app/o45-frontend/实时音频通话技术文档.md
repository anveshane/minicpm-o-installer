# 实时音频通话系统技术文档

## 目录

1. [系统架构概述](#系统架构概述)
2. [完整流程说明](#完整流程说明)
3. [接口调用详解](#接口调用详解)
4. [状态机管理](#状态机管理)
5. [音频处理流程](#音频处理流程)
6. [WebRTC连接详解](#webrtc连接详解)
7. [性能优化策略](#性能优化策略)
8. [异常处理机制](#异常处理机制)

---

## 系统架构概述

本项目基于 **LiveKit + WebRTC** 实现了低延迟的实时音频/视频通话系统，支持单工和双工两种模式。

### 核心技术栈

- **前端框架**: Vue 3 + Vite
- **WebRTC库**: LiveKit Client SDK
- **音频处理**: Web Audio API
- **状态管理**: Vue Reactive API
- **时间同步**: 自定义时间同步模块

### 系统组件

```
┌─────────────────────────────────────────────────────────┐
│                    前端应用层                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ Voice组件     │  │ Video组件     │  │ Scene组件    │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                   LiveKit Hook层                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │  useLiveKit.js (状态管理、房间管理、轨道管理)         │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                   LiveKit Client SDK                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ Room管理      │  │ Track管理     │  │ DataChannel  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│                   WebRTC 底层                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ PeerConnection│  │ MediaStream  │  │ RTCDataChannel│ │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                           ↓
                    LiveKit Server
                           ↓
                      AI模型后端
```

---

## 完整流程说明

### 1. 用户发起通话

#### 1.1 用户点击"开始通话"按钮

**组件**: `Voice_new_rtc.vue` → `initRecording()`

**流程**:

```javascript
initRecording() {
    // 1. 检查用户登录状态
    const userInfo = localStorage.getItem('userInfo')
    if (!userInfo.token) {
        emits('handleLogin') // 触发登录弹窗
        return
    }

    // 2. 设置loading状态
    callLoading.value = true

    // 3. 获取RTC Token
    await getRtcToken({ userToken: userInfo.token })

    // 4. 建立LiveKit连接
    await joinLiveKitRoom()
}
```

#### 1.2 获取RTC Token

**接口**: `/api/login`

**请求参数**:

```javascript
{
    modelType: 'simplex' | 'duplex',  // 单工或双工模式
    durVadTime: 0.5,                  // VAD抢跑检测时长(可选)
    durVadThreshold: 0.3,             // VAD抢跑检测阈值(可选)
    vadRace: true                     // 是否开启VAD抢跑(可选)
}
```

**响应数据**:

```javascript
{
    code: 0,
    data: {
        token: 'eyJhbGciOiJIUzI1NiJ9...',  // LiveKit房间Token
        userId: 'user_xxx',                 // 用户ID
        sessionId: 'session_xxx',           // 会话ID
        roomName: 'room_xxx'                // 房间名称
    }
}
```

**说明**:

- Token用于LiveKit房间认证
- userId和sessionId存储在localStorage，用于后续反馈等功能
- Token有时效性，过期需要重新获取

---

### 2. LiveKit房间连接

#### 2.1 连接LiveKit服务器

**Hook**: `useLiveKit.js` → `joinRoom()`

**连接配置**:

```javascript
const roomOptions = {
    adaptiveStream: true, // 自适应流
    dynacast: true, // 动态联播
    publishDefaults: {
        simulcast: true, // 联播
        dtx: false, // 关闭间断传输(降低延迟)
        maxPacketTime: 5, // 音频包时间5ms(降低延迟)
        red: false, // 关闭冗余编码(降低延迟)
        forceStereo: false
    }
};

const connectOptions = {
    autoSubscribe: true, // 自动订阅远端流
    maxRetries: 3, // 最大重试3次
    peerConnectionTimeout: 15000 // 15秒超时
};
```

**连接步骤**:

```javascript
// 1. 创建Room实例
const room = new Room(roomOptions);

// 2. 连接到LiveKit服务器
await room.connect(url, token, {
    ...connectOptions,
    metadata: JSON.stringify({ mode: 'audio', ...config })
});

// 3. 创建并发布本地音频轨道
const audioTrack = await createLocalAudioTrack();
await room.localParticipant.publishTrack(audioTrack);

// 4. 订阅远端参与者的轨道
room.remoteParticipants.forEach(subscribeParticipant);
```

#### 2.2 监听房间事件

**关键事件监听**:

1. **连接状态变化** (`ConnectionStateChanged`)

```javascript
room.on(RoomEvent.ConnectionStateChanged, connectionState => {
    // connected | reconnecting | disconnected
    console.log('连接状态:', connectionState);
});
```

2. **远端轨道订阅** (`TrackSubscribed`)

```javascript
room.on(RoomEvent.TrackSubscribed, (track, _, participant) => {
    if (track.kind === 'audio') {
        // 设置极低的播放延迟
        track.setPlayoutDelay(0);

        // 将音频轨道attach到<audio>元素
        track.attach(audioElement);

        // 记录订阅时间(用于性能监测)
        console.log('音频轨道已订阅');
    }
});
```

3. **参与者说话状态** (`IsSpeakingChanged`)

```javascript
participant.on(ParticipantEvent.IsSpeakingChanged, speaking => {
    if (speaking) {
        // 远端开始说话
        state.status = 'talking';
        console.log('远端开始播放音频');
    } else {
        // 远端停止说话，启动静默检测
        setTimeout(() => {
            // 检查是否真的停止了
            if (noOneIsSpeaking && state.generateEnd) {
                state.status = 'listening';
                sendText('<state><play_end>');
            }
        }, 1500); // 1.5秒静默超时
    }
});
```

4. **DataChannel消息** (`ChatMessage`)

```javascript
room.on(RoomEvent.ChatMessage, (msg, participant) => {
    // 处理后端发送的状态信号和文本消息
    handleChatMessage(msg, participant);
});
```

#### 2.3 无机器人检测机制

**目的**: 防止用户长时间等待无响应

**实现**:

```javascript
function startNoRobotTimer(room) {
    // 开发环境10秒，生产环境3分钟
    const TIMEOUT_MS = isLocalhost ? 10 * 1000 : 3 * 60 * 1000;

    noRobotTimer = setTimeout(() => {
        if (room.remoteParticipants.size === 0) {
            // 3分钟内无机器人加入
            alert('连接超时，未能成功连接到服务，将自动挂断。');
            leaveRoom();
        }
    }, TIMEOUT_MS);
}

// 有远端参与者加入时清除定时器
room.on(RoomEvent.ParticipantConnected, participant => {
    if (noRobotTimer) {
        clearTimeout(noRobotTimer);
        noRobotTimer = null;
    }
});
```

---

### 3. 状态机管理

#### 3.1 状态流转图

```
                    [开始]
                      ↓
            点击"开始通话"按钮
                      ↓
              [connecting] ← 正在连接LiveKit
                      ↓
        收到 <state><session_init>
                      ↓
┌───────→ [listening] ← 监听用户说话
│                     ↓
│             用户开始说话
│                     ↓
│         收到 <state><vad_end>
│                     ↓
│              [thinking] ← AI思考中
│                     ↓
│       收到 <state><generate_start>
│                     ↓
│       收到 <state><audio_start>
│                     ↓
│         检测到远端音频播放
│                     ↓
│               [talking] ← AI回复中
│                     ↓
│       收到 <state><generate_end>
│                     ↓
│           音频播放完毕
└─────────────────────┘

特殊状态:
  [forbidden] ← 收到 <state><audit_stop> (违规内容)
```

#### 3.2 状态详细说明

| 状态         | 说明     | 触发条件                         | 视觉表现         |
| ------------ | -------- | -------------------------------- | ---------------- |
| `connecting` | 正在连接 | 调用`joinRoom()`后               | 显示"连接中"动画 |
| `listening`  | 监听中   | 收到`session_init`或音频播放结束 | 显示"监听"动画   |
| `thinking`   | 思考中   | 收到`vad_end`信号                | 显示"思考"动画   |
| `talking`    | 回复中   | 检测到远端音频播放               | 显示"说话"动画   |
| `forbidden`  | 违规     | 收到`audit_stop`信号             | 显示提示文本     |

#### 3.3 关键状态信号

后端通过DataChannel发送状态信号（文本消息）:

1. **`<state><session_init>`** - 会话初始化完成
    - 前端切换到 `listening` 状态
    - 开始监听用户说话

2. **`<state><vad_end>`** - 用户说话结束（VAD检测）
    - 前端切换到 `thinking` 状态
    - 显示AI思考中

3. **`<state><generate_start>`** - AI开始生成回答
    - 记录生成开始时间
    - 创建新的消息记录

4. **`<state><audio_start>`** - 音频开始信号
    - 记录音频开始信号时间
    - 等待实际音频播放检测

5. **`<state><generate_end>`** - AI生成结束
    - 标记 `generateEnd = true`
    - 等待音频播放完毕后切换到 `listening`

6. **`<state><play_end>`** - 音频播放结束（前端发送给后端）
    - 前端检测到音频播放完毕后发送
    - 通知后端可以开始下一轮交互

7. **`<state><audit_stop>`** - 安全审核拦截
    - 切换到 `forbidden` 状态
    - 显示提示信息

---

### 4. 音频输入处理

#### 4.1 本地音频采集

**使用LiveKit的本地音频轨道**:

```javascript
// 创建本地音频轨道
const audioTrack = await createLocalAudioTrack({
    // 音频约束
    echoCancellation: true, // 回声消除
    noiseSuppression: true, // 噪声抑制
    autoGainControl: true // 自动增益控制
});

// 发布到房间
await room.localParticipant.publishTrack(audioTrack);
```

#### 4.2 本地音频传输

**自动传输**:

- LiveKit SDK自动处理音频编码和传输
- 使用Opus编解码器（低延迟高质量）
- 通过WebRTC的RTP协议传输

**传输配置**:

```javascript
publishDefaults: {
    dtx: false,           // 关闭间断传输(降低延迟)
    maxPacketTime: 5,     // 5ms音频包(降低延迟)
    red: false           // 关闭冗余编码(降低延迟)
}
```

#### 4.3 VAD (Voice Activity Detection)

**VAD配置**: 后端配置，前端通过`getRtcToken`接口传递参数

```javascript
{
    durVadTime: 0.5,          // 检测时长500ms
    durVadThreshold: 0.3,     // 检测阈值0.3
    vadRace: true             // 开启VAD抢跑
}
```

**VAD抢跑**: 在用户还在说话时就开始准备生成回复，减少延迟

---

### 5. 音频输出处理

#### 5.1 远端音频接收

**轨道订阅流程**:

```javascript
room.on(RoomEvent.TrackSubscribed, (track, _, participant) => {
    if (track.kind === 'audio') {
        // 1. 设置极低的播放延迟
        track.setPlayoutDelay(0); // 0ms延迟

        // 2. 获取对应的<audio>元素
        const audioElement = remoteAudioRefs[participant.sid];

        // 3. 将轨道attach到<audio>元素
        track.attach(audioElement);

        // 4. <audio>元素自动播放
        // (因为设置了autoplay属性)
    }
});
```

#### 5.2 音频元素配置

**HTML模板**:

```html
<div class="remote-audio" v-for="(tracks, sid) in state.remoteTracks" :key="sid">
    <audio
        :ref="setRemoteAudioRef(sid)"
        autoplay          <!-- 自动播放 -->
        playsinline       <!-- 行内播放(移动端) -->
        preload="auto"    <!-- 预加载 -->
        :muted="false"    <!-- 不静音 -->
        :data-livekit-audio="sid"  <!-- 标记用于DOM查询 -->
    ></audio>
</div>
```

**动态ref绑定**:

```javascript
const remoteAudioRefs = {};

function setRemoteAudioRef(sid) {
    return el => {
        if (!el) return;

        // 存储引用
        remoteAudioRefs[sid] = el;

        // 优化配置
        el.autoplay = true;
        el.playsInline = true;
        el.preload = 'none'; // 不预加载(减少初始化延迟)
        el.muted = false;
    };
}
```

#### 5.3 音频播放检测

**方法1: 基于IsSpeakingChanged事件** (主要方法)

```javascript
participant.on(ParticipantEvent.IsSpeakingChanged, speaking => {
    if (speaking) {
        // 远端开始说话
        state.remoteAudioActive[sid] = true;

        // 切换到talking状态
        if (state.status === 'thinking') {
            state.status = 'talking';
        }
    } else {
        // 远端停止说话，启动静默检测
        startSilenceDetection(sid);
    }
});
```

**方法2: 基于DOM检查** (辅助方法)

```javascript
function checkAudioElementsStatus() {
    const audioElements = document.querySelectorAll('audio[data-livekit-audio]');
    let hasPlayingAudio = false;

    audioElements.forEach(audio => {
        // 严格的播放状态检查
        const isActuallyPlaying = !audio.paused && !audio.ended && audio.currentTime > 0 && audio.readyState >= 2;

        // 检查是否接近结束
        const isNearEnd = audio.duration && audio.currentTime && audio.duration - audio.currentTime < 0.1;

        if (isActuallyPlaying && !isNearEnd) {
            hasPlayingAudio = true;
        }
    });

    return hasPlayingAudio;
}
```

#### 5.4 静默检测与状态切换

**两级检测机制**:

```javascript
function handleSpeakingChanged(participant, speaking) {
    if (!speaking) {
        // 第一级: 1.5秒静默超时
        setTimeout(() => {
            const remoteStillSpeaking = Object.values(state.remoteAudioActive).some(v => v);

            if (!remoteStillSpeaking && state.generateEnd && state.status === 'talking') {
                // 第二级: 300ms精确检查
                setTimeout(() => {
                    const finalRemoteCheck = Object.values(state.remoteAudioActive).some(v => v);

                    if (!finalRemoteCheck && state.generateEnd) {
                        // DOM检查作为最后保险
                        const audioElementsPlaying = checkAudioElementsStatus();

                        if (!audioElementsPlaying) {
                            // 确认停止，切换状态
                            state.status = 'listening';
                            sendText('<state><play_end>');
                        }
                    }
                }, 300);
            }
        }, 1500);
    }
}
```

**说明**:

- 1.5秒静默超时: 平衡精确性和可靠性
- 300ms精确检查: 避免过早切换状态
- DOM检查: 防止状态不一致
- 必须满足: `generateEnd=true` + `status='talking'` + 无人说话

---

### 6. DataChannel通信

#### 6.1 发送消息

**发送文本消息**:

```javascript
function sendText(text, flag = false) {
    if (!state.room || !state.connected) return;

    // 通过LiveKit的DataChannel发送
    state.room.localParticipant.sendText(text, { topic: 'lk.chat' });

    // 记录到本地消息列表
    if (flag) {
        state.messageIndex++;
        state.chatMessages.push({
            type: 'user',
            text: JSON.parse(text).text
        });
    }
}
```

**发送打断信号**:

```javascript
function interruptChat() {
    // 发送打断指令
    sendText(
        JSON.stringify({
            interface: 'break'
        })
    );

    // 立即执行前端打断操作
    handleInterfaceBreak();
}

function handleInterfaceBreak() {
    // 1. 切换状态
    state.status = 'listening';
    state.generateEnd = true;

    // 2. 清空远端说话状态
    state.remoteAudioActive = {};

    // 3. 停止所有远端音频播放
    for (const sid in state.remoteTracks) {
        for (const track of state.remoteTracks[sid]) {
            track.detach();
            track.stop();
        }
    }

    // 4. 清空远端轨道
    state.remoteTracks = {};
}
```

#### 6.2 接收消息

**注册消息处理器**:

```javascript
room.on(RoomEvent.ChatMessage, handleChatMessage);

room.registerTextStreamHandler('lk.chat', async (reader, participant) => {
    const info = reader.info;
    handleChatMessage(
        {
            id: info.id,
            timestamp: info.timestamp,
            message: await reader.readAll()
        },
        participant
    );
});
```

**消息类型处理**:

```javascript
function handleChatMessage(msg, participant) {
    const message = msg.message;

    // 1. 状态信号
    if (message.includes('<state><session_init>')) {
        state.status = 'listening';
    } else if (message.includes('<state><vad_end>')) {
        state.status = 'thinking';
    } else if (message.includes('<state><generate_start>')) {
        state.messageIndex++;
        state.chatMessages.push({ type: 'robot', text: '' });
        state.generateEnd = false;
    } else if (message.includes('<state><audio_start>')) {
        // 等待实际音频播放检测
    } else if (message.includes('<state><generate_end>')) {
        state.generateEnd = true;
        // 启动音频结束检测
    } else if (message.includes('<state><audit_stop>')) {
        state.status = 'forbidden';
        state.chatMessages[state.messageIndex].text = '换一个问题聊吧～';
    }

    // 2. 普通文本消息
    else if (!message.includes('<state>')) {
        // 提取文本（去除时间戳）
        let text = message;
        if (message.includes('<time>') && message.includes('</time>')) {
            text = message.split('</time>')[1];
        }

        // 追加到当前消息
        state.chatMessages[state.messageIndex].text += text;
    }
}
```

---

### 7. 性能监测

#### 7.1 关键时间点记录

**轮次记录结构**:

```javascript
state.audioRounds = [
    {
        round: 0, // 轮次
        participantSid: 'PA_xxx', // 参与者ID
        generateStartAt: 1000.0, // 生成开始时间(ms)
        audioStartSignalAt: 1200.0, // 音频开始信号时间(ms)
        firstPacketAt: 1250.0, // 首包到达时间(ms)
        firstPlayAt: 1280.0, // 首次播放时间(ms)
        deltas: {
            fromGenerateStart: 250, // 从生成开始到首包(ms)
            fromAudioStartSignal: 50, // 从音频信号到首包(ms)
            packetToPlay: 30, // 从首包到播放(ms)
            fromGenerateStartToPlay: 280 // 从生成开始到播放(ms)
        }
    }
];
```

**记录时机**:

1. **生成开始**: 收到`<state><generate_start>`

```javascript
state.audioRounds.push({
    round: state.audioRounds.length,
    generateStartAt: performance.now(),
    ...
})
```

2. **音频信号**: 收到`<state><audio_start>`

```javascript
const round = state.audioRounds[state.pendingRoundIndex];
round.audioStartSignalAt = performance.now();
```

3. **首包到达**: `IsSpeakingChanged` 事件触发

```javascript
function markFirstPacket(participant) {
    const round = state.audioRounds[state.pendingRoundIndex];
    if (!round.firstPacketAt) {
        round.firstPacketAt = performance.now();

        // 计算延迟
        if (round.generateStartAt) {
            round.deltas.fromGenerateStart = round.firstPacketAt - round.generateStartAt;
        }
    }
}
```

4. **首次播放**: `<audio>` 元素 `playing` 事件

```javascript
audioElement.onplaying = () => {
    const round = state.audioRounds[state.pendingRoundIndex];
    if (!round.firstPlayAt) {
        round.firstPlayAt = performance.now();

        // 计算播放延迟
        round.deltas.packetToPlay = round.firstPlayAt - round.firstPacketAt;
    }
};
```

#### 7.2 性能指标

| 指标                      | 说明                   | 目标值  |
| ------------------------- | ---------------------- | ------- |
| `fromGenerateStart`       | 从AI开始生成到首包到达 | < 500ms |
| `fromAudioStartSignal`    | 从音频信号到首包到达   | < 100ms |
| `packetToPlay`            | 从首包到播放           | < 50ms  |
| `fromGenerateStartToPlay` | 从生成到播放(总延迟)   | < 700ms |

---

### 8. 完整时序图

```
用户端                LiveKit客户端           LiveKit服务器          AI后端
  │                        │                      │                   │
  │  1. 点击"开始通话"      │                      │                   │
  ├────────────────────────>│                      │                   │
  │                        │                      │                   │
  │  2. getRtcToken()      │                      │                   │
  ├─────────────────────────────────────────────────────────────────>│
  │                        │                      │                   │
  │  3. 返回 Token         │                      │                   │
  │<─────────────────────────────────────────────────────────────────┤
  │                        │                      │                   │
  │  4. joinRoom(url, token)                      │                   │
  │                        ├─────────────────────>│                   │
  │                        │                      │                   │
  │  5. 连接成功           │                      │                   │
  │                        │<─────────────────────┤                   │
  │                        │                      │                   │
  │  6. 发布本地音频轨道    │                      │                   │
  │                        ├─────────────────────>│                   │
  │                        │                      │                   │
  │  7. AI参与者加入       │                      │                   │
  │                        │<─────────────────────┤<──────────────────┤
  │                        │                      │                   │
  │  8. 订阅远端音频轨道    │                      │                   │
  │                        ├─────────────────────>│                   │
  │                        │                      │                   │
  │  9. <session_init>     │                      │                   │
  │<───────────────────────┤<─────────────────────┤<──────────────────┤
  │    状态: listening     │                      │                   │
  │                        │                      │                   │
  │ 10. 用户说话           │                      │                   │
  ├────────────────────────>│                      │                   │
  │    (音频流自动传输)     ├─────────────────────>├──────────────────>│
  │                        │                      │                   │
  │ 11. <vad_end>          │                      │                   │
  │<───────────────────────┤<─────────────────────┤<──────────────────┤
  │    状态: thinking      │                      │                   │
  │                        │                      │                   │
  │ 12. <generate_start>   │                      │                   │
  │<───────────────────────┤<─────────────────────┤<──────────────────┤
  │                        │                      │                   │
  │ 13. <audio_start>      │                      │                   │
  │<───────────────────────┤<─────────────────────┤<──────────────────┤
  │                        │                      │                   │
  │ 14. AI音频流           │                      │                   │
  │<───────────────────────┤<─────────────────────┤<──────────────────┤
  │    检测到播放          │                      │                   │
  │    状态: talking       │                      │                   │
  │                        │                      │                   │
  │ 15. <generate_end>     │                      │                   │
  │<───────────────────────┤<─────────────────────┤<──────────────────┤
  │                        │                      │                   │
  │ 16. 音频播放完毕       │                      │                   │
  │    检测静默1.5s+300ms  │                      │                   │
  │    状态: listening     │                      │                   │
  │                        │                      │                   │
  │ 17. <play_end>         │                      │                   │
  ├────────────────────────>├─────────────────────>├──────────────────>│
  │                        │                      │                   │
  │ 18. 循环 10-17         │                      │                   │
  │    ...                 │                      │                   │
  │                        │                      │                   │
  │ 19. 点击"挂断"         │                      │                   │
  ├────────────────────────>│                      │                   │
  │                        │                      │                   │
  │ 20. leaveRoom()        │                      │                   │
  │                        ├─────────────────────>│                   │
  │                        │                      ├──────────────────>│
  │                        │                      │                   │
  │ 21. 清理资源           │                      │                   │
  │<───────────────────────┤                      │                   │
  │                        │                      │                   │
```

---

### 9. 接口总结

#### 9.1 HTTP接口

| 接口                    | 方法 | 说明           | 调用时机   |
| ----------------------- | ---- | -------------- | ---------- |
| `/api/login`            | POST | 获取RTC Token  | 开始通话时 |
| `/api/logout`           | POST | 注销RTC连接    | 结束通话时 |
| `/api/restart_model`    | POST | 重启模型       | 手动重启   |
| `/api/session_feedback` | POST | 点赞点踩反馈   | 通话过程中 |
| `/api/get_system_time`  | GET  | 获取服务器时间 | 时间同步   |

#### 9.2 WebRTC/LiveKit接口

**房间管理**:

- `room.connect(url, token, options)` - 连接房间
- `room.disconnect()` - 断开连接
- `room.localParticipant.publishTrack(track)` - 发布轨道
- `room.localParticipant.unpublishTrack(track)` - 取消发布轨道

**消息通信**:

- `room.localParticipant.sendText(text, options)` - 发送文本消息
- `room.on(RoomEvent.ChatMessage, handler)` - 接收消息

**轨道管理**:

- `createLocalAudioTrack(options)` - 创建本地音频轨道
- `track.attach(element)` - 将轨道附加到DOM元素
- `track.detach()` - 分离轨道
- `track.stop()` - 停止轨道

#### 9.3 状态信号协议

**前端发送**:

- `<state><play_end>` - 音频播放结束
- `{"interface": "break"}` - 打断当前对话

**后端发送**:

- `<state><session_init>` - 会话初始化完成
- `<state><vad_end>` - 用户说话结束
- `<state><generate_start>` - 开始生成回答
- `<state><audio_start>` - 音频开始
- `<state><generate_end>` - 生成结束
- `<state><audit_stop>` - 安全审核拦截
- 普通文本消息 - AI回复内容

---

### 10. 优化策略总结

#### 10.1 延迟优化

1. **音频编码优化**
    - 关闭DTX（间断传输）
    - 设置5ms音频包时间
    - 关闭RED（冗余编码）

2. **播放延迟优化**
    - 设置0ms播放延迟 `track.setPlayoutDelay(0)`
    - 关闭音频预加载 `preload="none"`
    - 立即attach轨道到DOM

3. **状态切换优化**
    - 基于实际音频播放检测（IsSpeakingChanged）
    - 两级检测机制（1.5s + 300ms）
    - DOM检查作为辅助

4. **VAD抢跑**
    - 用户说话时提前开始生成
    - 减少等待时间

#### 10.2 稳定性优化

1. **无机器人检测**
    - 3分钟超时机制
    - 防止用户长时间等待

2. **重连机制**
    - LiveKit自动重连
    - 最大重试3次

3. **音频结束检测**
    - 状态检测 + DOM检查
    - 防止状态不一致

4. **错误处理**
    - try-catch包裹关键操作
    - 优雅降级

---

### 11. 常见问题

#### Q1: 音频延迟大怎么办？

**排查步骤**:

1. 检查网络延迟（ping LiveKit服务器）
2. 查看性能监测数据（audioRounds）
3. 检查是否启用了音频优化配置
4. 查看浏览器控制台是否有警告

#### Q2: 音频播放卡顿

**可能原因**:

1. 网络抖动
2. 音频缓冲区不足
3. CPU占用过高
4. 浏览器兼容性问题

**解决方案**:

1. 增加`maxPacketTime`参数
2. 检查并关闭其他占用资源的应用
3. 更换浏览器（推荐Chrome）

#### Q3: 状态切换不及时

**检查项**:

1. 是否收到对应的状态信号
2. `generateEnd`标志是否正确
3. `remoteAudioActive`状态是否准确
4. 静默检测时间是否合适

#### Q4: 无法听到远端音频

**排查步骤**:

1. 检查<audio>元素是否创建
2. 检查轨道是否成功attach
3. 检查音频元素是否静音
4. 检查浏览器音频权限
5. 检查LiveKit连接状态

---

### 12. 开发建议

#### 12.1 调试技巧

1. **开启详细日志**

```javascript
import { setLogLevel, LogLevel } from 'livekit-client';
setLogLevel(LogLevel.debug);
```

2. **监测性能指标**

```javascript
console.log('音频轮次数据:', state.audioRounds);
```

3. **检查连接状态**

```javascript
console.log('Room状态:', {
    connected: state.connected,
    status: state.status,
    remoteTracks: Object.keys(state.remoteTracks).length,
    remoteAudioActive: state.remoteAudioActive
});
```

#### 12.2 测试要点

1. **功能测试**
    - 正常通话流程
    - 打断功能
    - 重连功能
    - 多轮对话

2. **性能测试**
    - 首包延迟
    - 端到端延迟
    - 音频质量
    - CPU/内存占用

3. **兼容性测试**
    - Chrome、Firefox、Safari
    - 移动端浏览器
    - 不同网络环境

4. **异常测试**
    - 网络断开
    - Token过期
    - 服务器无响应
    - 并发用户

---

## 结语

本文档详细描述了基于LiveKit的实时音频通话系统的完整技术实现。系统通过精心设计的状态机、优化的音频处理流程和可靠的通信机制，实现了低延迟、高质量的实时音频交互体验。

**关键技术点**:

- LiveKit + WebRTC 提供底层通信能力
- 状态机确保交互流程清晰可控
- 多层检测机制保证状态切换准确
- 性能监测帮助持续优化
- 完善的错误处理提升稳定性

**优化成果**:

- 端到端延迟 < 700ms
- 音频质量接近原生应用
- 支持单工和双工两种模式
- 完善的异常处理和重连机制
