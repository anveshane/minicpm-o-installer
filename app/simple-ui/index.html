<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MiniCPM-o Simple Chat</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #f7f7f8; --surface: #fff; --border: #e5e5e5;
  --text: #1a1a1a; --text-secondary: #6b6b6b;
  --primary: #2563eb; --primary-hover: #1d4ed8;
  --user-bg: #e8f0fe; --assistant-bg: #f0f0f0;
  --radius: 12px;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: var(--bg); color: var(--text);
  height: 100vh; display: flex; flex-direction: column;
}
header {
  background: var(--surface); border-bottom: 1px solid var(--border);
  padding: 12px 20px; display: flex; align-items: center; gap: 12px;
  flex-shrink: 0;
}
header h1 { font-size: 18px; font-weight: 600; }
header .badge {
  font-size: 11px; background: #dcfce7; color: #166534;
  padding: 2px 8px; border-radius: 10px;
}
header .clear-btn {
  margin-left: auto; background: none; border: 1px solid var(--border);
  padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 13px;
  color: var(--text-secondary);
}
header .clear-btn:hover { background: #fee2e2; color: #dc2626; border-color: #fca5a5; }

#chat {
  flex: 1; overflow-y: auto; padding: 20px;
  display: flex; flex-direction: column; gap: 16px;
}
.msg { display: flex; gap: 10px; max-width: 85%; line-height: 1.6; }
.msg.user { align-self: flex-end; flex-direction: row-reverse; }
.msg .bubble {
  padding: 10px 16px; border-radius: var(--radius); font-size: 14px;
  word-break: break-word; white-space: pre-wrap;
}
.msg.user .bubble { background: var(--user-bg); }
.msg.assistant .bubble { background: var(--assistant-bg); }
.msg .bubble img, .msg .bubble video { max-width: 280px; max-height: 200px; border-radius: 8px; display: block; margin: 6px 0; }
.msg .bubble audio { display: block; margin: 6px 0; }
.msg .bubble video { cursor: pointer; }
.msg .bubble code { background: #e2e2e2; padding: 1px 5px; border-radius: 4px; font-size: 13px; }
.msg .bubble pre { background: #1e1e1e; color: #d4d4d4; padding: 12px; border-radius: 8px; overflow-x: auto; margin: 8px 0; }
.msg .bubble pre code { background: none; padding: 0; color: inherit; }
.msg .avatar {
  width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; font-weight: 600;
}
.msg.user .avatar { background: var(--primary); color: #fff; }
.msg.assistant .avatar { background: #e5e5e5; color: #333; }

.welcome {
  text-align: center; color: var(--text-secondary); margin: auto;
  padding: 40px 20px;
}
.welcome h2 { font-size: 22px; color: var(--text); margin-bottom: 8px; }
.welcome p { font-size: 14px; }

/* Attachments preview */
#attachments {
  display: flex; gap: 8px; padding: 0 20px; flex-wrap: wrap;
}
#attachments:empty { display: none; }
.attach-item {
  position: relative; background: var(--surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 6px 10px; font-size: 12px;
  display: flex; align-items: center; gap: 6px;
}
.attach-item img, .attach-item video { height: 40px; border-radius: 4px; }
.attach-item .remove {
  cursor: pointer; color: #999; font-size: 16px; line-height: 1;
}
.attach-item .remove:hover { color: #dc2626; }
.attach-item.loading { opacity: 0.6; }
.attach-item .spinner {
  width: 14px; height: 14px; border: 2px solid var(--border);
  border-top-color: var(--primary); border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
.attach-item .file-size { color: var(--text-secondary); font-size: 11px; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Input area */
#input-area {
  background: var(--surface); border-top: 1px solid var(--border);
  padding: 12px 20px; display: flex; gap: 8px; align-items: flex-end;
  flex-shrink: 0;
}
#input-area textarea {
  flex: 1; border: 1px solid var(--border); border-radius: var(--radius);
  padding: 10px 14px; font-size: 14px; resize: none;
  font-family: inherit; line-height: 1.5; max-height: 150px;
  outline: none;
}
#input-area textarea:focus { border-color: var(--primary); }
.icon-btn {
  width: 40px; height: 40px; border: none; border-radius: 50%;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  background: none; color: var(--text-secondary); flex-shrink: 0;
}
.icon-btn:hover { background: #f0f0f0; }
.icon-btn.send { background: var(--primary); color: #fff; }
.icon-btn.send:hover { background: var(--primary-hover); }
.icon-btn.send:disabled { background: #93c5fd; cursor: not-allowed; }
.icon-btn svg { width: 20px; height: 20px; }

/* Drop overlay */
#drop-overlay {
  display: none; position: fixed; inset: 0; background: rgba(37,99,235,.12);
  border: 3px dashed var(--primary); z-index: 100;
  align-items: center; justify-content: center;
  font-size: 20px; color: var(--primary); font-weight: 600;
}
body.dragging #drop-overlay { display: flex; }

/* Spinner for streaming */
@keyframes blink { 50% { opacity: 0; } }
.typing::after { content: "\25CF"; animation: blink 1s steps(1) infinite; margin-left: 2px; }
</style>
</head>
<body>

<header>
  <h1>MiniCPM-o</h1>
  <span class="badge">Simple Chat</span>
  <button class="clear-btn" onclick="clearChat()">Clear Chat</button>
</header>

<div id="chat">
  <div class="welcome">
    <h2>MiniCPM-o Simple Chat</h2>
    <p>Text, image, audio, and video multimodal chat. Upload files or type a message to get started.</p>
  </div>
</div>

<div id="attachments"></div>

<div id="input-area">
  <input type="file" id="file-input" accept="image/*,audio/*,video/*" multiple hidden>
  <!-- Image button -->
  <button class="icon-btn" onclick="document.getElementById('file-input').click()" title="Attach image, audio, or video">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
      <path d="m21 15-5-5L5 21"/>
    </svg>
  </button>
  <textarea id="msg-input" rows="1" placeholder="Type a message..." autofocus></textarea>
  <button class="icon-btn send" id="send-btn" onclick="sendMessage()" title="Send">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
  </button>
</div>

<div id="drop-overlay">Drop files here</div>

<script>
const chatEl = document.getElementById('chat');
const inputEl = document.getElementById('msg-input');
const attachEl = document.getElementById('attachments');
const sendBtn = document.getElementById('send-btn');
const fileInput = document.getElementById('file-input');

let messages = []; // OpenAI-format message history
let attachments = []; // { type: 'image'|'audio'|'video', name, base64, mime, dataUrl, loading }
let streaming = false;

// Auto-resize textarea
inputEl.addEventListener('input', () => {
  inputEl.style.height = 'auto';
  inputEl.style.height = Math.min(inputEl.scrollHeight, 150) + 'px';
});

// Enter to send, Shift+Enter for newline
inputEl.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});

// File input
fileInput.addEventListener('change', () => {
  for (const f of fileInput.files) addFile(f);
  fileInput.value = '';
});

// Drag & drop
document.addEventListener('dragover', e => { e.preventDefault(); document.body.classList.add('dragging'); });
document.addEventListener('dragleave', e => {
  if (e.relatedTarget === null) document.body.classList.remove('dragging');
});
document.addEventListener('drop', e => {
  e.preventDefault(); document.body.classList.remove('dragging');
  for (const f of e.dataTransfer.files) addFile(f);
});

function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

function addFile(file) {
  const isImage = file.type.startsWith('image/');
  const isAudio = file.type.startsWith('audio/');
  const isVideo = file.type.startsWith('video/');
  if (!isImage && !isAudio && !isVideo) return;

  const type = isImage ? 'image' : isVideo ? 'video' : 'audio';

  // Create a blob URL immediately for preview (avoids huge base64 in DOM)
  const blobUrl = URL.createObjectURL(file);

  // Add a loading placeholder immediately
  const idx = attachments.length;
  attachments.push({
    type,
    name: file.name,
    size: file.size,
    base64: null,
    mime: file.type,
    blobUrl,
    loading: true
  });
  renderAttachments();

  const reader = new FileReader();
  reader.onload = () => {
    const base64 = reader.result.split(',')[1];
    attachments[idx].base64 = base64;
    attachments[idx].loading = false;
    renderAttachments();
  };
  reader.onerror = () => {
    attachments[idx].loading = false;
    attachments[idx].error = true;
    renderAttachments();
  };
  reader.readAsDataURL(file);
}

function renderAttachments() {
  attachEl.innerHTML = attachments.map((a, i) => {
    if (a.loading) {
      return `<div class="attach-item loading"><span class="spinner"></span><span>${escHtml(a.name)}</span><span class="file-size">${formatSize(a.size)}</span></div>`;
    }
    if (a.error) {
      return `<div class="attach-item"><span style="color:#dc2626">Failed</span><span>${escHtml(a.name)}</span><span class="remove" onclick="removeAttach(${i})">&times;</span></div>`;
    }
    let preview;
    if (a.type === 'image') {
      preview = `<img src="${a.blobUrl}" alt="${escHtml(a.name)}">`;
    } else if (a.type === 'video') {
      preview = `<video src="${a.blobUrl}" muted></video>`;
    } else {
      preview = `<span>${escHtml(a.name)}</span>`;
    }
    return `<div class="attach-item">${preview}<span class="file-size">${formatSize(a.size)}</span><span class="remove" onclick="removeAttach(${i})">&times;</span></div>`;
  }).join('');
}

function removeAttach(i) {
  const a = attachments[i];
  if (a && a.blobUrl) URL.revokeObjectURL(a.blobUrl);
  attachments.splice(i, 1);
  renderAttachments();
}

function clearChat() {
  messages = [];
  attachments = [];
  chatEl.innerHTML = `<div class="welcome"><h2>MiniCPM-o Simple Chat</h2><p>Text, image, audio, and video multimodal chat. Upload files or type a message to get started.</p></div>`;
  attachEl.innerHTML = '';
}

function appendMsg(role, contentHtml) {
  // Remove welcome
  const welcome = chatEl.querySelector('.welcome');
  if (welcome) welcome.remove();

  const div = document.createElement('div');
  div.className = `msg ${role}`;
  const avatarText = role === 'user' ? 'U' : 'A';
  div.innerHTML = `<div class="avatar">${avatarText}</div><div class="bubble">${contentHtml}</div>`;
  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return div.querySelector('.bubble');
}

function renderMarkdown(text) {
  // Minimal markdown: code blocks, inline code, bold, italic
  let html = text
    .replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => `<pre><code>${escHtml(code.trim())}</code></pre>`)
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>');
  return html;
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

async function sendMessage() {
  if (streaming) return;
  if (attachments.some(a => a.loading)) return; // wait for files to finish loading
  const text = inputEl.value.trim();
  if (!text && attachments.length === 0) return;

  // Build user content parts
  const contentParts = [];
  const displayParts = [];

  for (const a of attachments) {
    if (a.loading || a.error) continue; // skip incomplete uploads
    if (a.type === 'image') {
      contentParts.push({
        type: 'image_url',
        image_url: { url: `data:${a.mime};base64,${a.base64}` }
      });
      displayParts.push(`<img src="${a.blobUrl}" alt="${escHtml(a.name)}">`);
    } else if (a.type === 'video') {
      contentParts.push({
        type: 'image_url',
        image_url: { url: `data:${a.mime};base64,${a.base64}` }
      });
      displayParts.push(`<video controls playsinline src="${a.blobUrl}"></video>`);
    } else {
      contentParts.push({
        type: 'input_audio',
        input_audio: { data: a.base64, format: a.mime.includes('wav') ? 'wav' : 'mp3' }
      });
      displayParts.push(`<audio controls src="${a.blobUrl}"></audio>`);
    }
  }

  if (text) {
    contentParts.push({ type: 'text', text });
    displayParts.push(escHtml(text));
  }

  // Show user message
  appendMsg('user', displayParts.join(''));

  // Add to history
  const userMsg = contentParts.length === 1 && contentParts[0].type === 'text'
    ? { role: 'user', content: text }
    : { role: 'user', content: contentParts };
  messages.push(userMsg);

  // Clear input
  inputEl.value = '';
  inputEl.style.height = 'auto';
  attachments = [];
  attachEl.innerHTML = '';

  // Stream response
  streaming = true;
  sendBtn.disabled = true;
  const bubble = appendMsg('assistant', '<span class="typing"></span>');
  let fullText = '';

  try {
    const res = await fetch('/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'minicpm-o',
        messages,
        stream: true,
        temperature: 0.7,
        max_tokens: 2048
      })
    });

    if (!res.ok) {
      const errText = await res.text();
      throw new Error(`HTTP ${res.status}: ${errText}`);
    }

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });

      const lines = buffer.split('\n');
      buffer = lines.pop(); // keep incomplete line

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || !trimmed.startsWith('data: ')) continue;
        const data = trimmed.slice(6);
        if (data === '[DONE]') continue;

        try {
          const json = JSON.parse(data);
          const delta = json.choices?.[0]?.delta?.content;
          if (delta) {
            fullText += delta;
            bubble.innerHTML = renderMarkdown(fullText);
            chatEl.scrollTop = chatEl.scrollHeight;
          }
        } catch {}
      }
    }
  } catch (err) {
    fullText = `Error: ${err.message}`;
    bubble.innerHTML = `<span style="color:#dc2626">${escHtml(fullText)}</span>`;
  }

  if (!fullText) {
    bubble.innerHTML = '<span style="color:#999">No response</span>';
  }

  messages.push({ role: 'assistant', content: fullText });
  streaming = false;
  sendBtn.disabled = false;
  inputEl.focus();
}
</script>
</body>
</html>
